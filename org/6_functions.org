#+TITLE:PYTHON FUNCTIONS
#+AUTHOR: Marcus Birkenkrahe
#+SUBTITLE: CSC 109 - Introduction to programming in Python - Summer 2023
#+STARTUP: overview hideblocks indent inlineimages entitiespretty
#+PROPERTY: header-args:python :results output :exports both :session *Python*
* Python Functions: Simplifying Your Code
#+attr_latex: :width 400px
#+caption: Llyfrgell Genedlaethol Cymru / Claerwen Dam (1952)
[[../img/functions.jpg]]

Why functions?
- Break down code into smaller, reusable pieces
- Make it easier to manage and maintain code
- Encapsulate tasks within functions
- Call function from anywhere

What are functions?
- ~def~ keyword
- Name of function
- Pair of parentheses ~()~
- Parameters of function
- Separator ~:~
- Body of the function
- Return values

* ~def~ Statements without Parameters

- Example 1: 'hello world' as a function without arguments:
  #+begin_src python
    # function call
    helloWorld()
    # function definition
    def helloWorld():
        print('Hello, world!')

  #+end_src

- Example 2: What will the output of this script be if you call ~howdy~
  three times in a row?
  #+begin_src python
    # function definition
    def howdy():
        print('Howdy!')
        print('Howdy!!')
        print('Hello there.')
        # function calls
    howdy()
    howdy()
    howdy()
  #+end_src

- You can view the execution of the program at [[https://autbor.com/hellofunc/][autbor.com/hellofunc/]]

* ~def~ Statement with Parameters

- You can define your own functions with /parameters/. When you pass
  /values/ to the function, these are called /arguments/.

- Example 3: 'hello' as a greeting with ~name~ input:
  #+begin_src python :results silent
    def hello(name):
        print('Hello, ' + name)
  #+end_src

- In this example, the function ~hello~ takes a parameter called
  ~name~. When the function is called with a name, it prints a greeting
  message using that name.
  #+begin_src python
    hello('Marcus')
    hello('Alice')
  #+end_src

- When the function returns from being called, the value stored in a
  parameter is forgotten: what's the output of this script given the
  definition of ~hello(name)~ above?
  #+begin_src python
    hello('Bob')
    hello(name)
  #+end_src

* Define, Call, Pass, Argument, Parameter, Recursion

- It may sound trivial, but it's not trivial to keep these concepts
  apart:
  #+name: tab_terms
  | TERM/COMMAND        | MEANING                                         |
  |---------------------+-------------------------------------------------|
  | Function definition | Create a function with ~def~ [name]([args]):      |
  | Function call       | Executing function (with/out passing arguments) |
  | Function argument   | Value passed to a function in a function call   |
  | Function parameter  | Variables that have arguments assigned to them  |

- Analyse this function and decide how to call it - what is 'result'?
  #+begin_src python :results silent
    def result(result):
        print(result)
  #+end_src

- Example calls:
  #+begin_src python
    result(12)
    result(12 + 500)
    result('a')
    result('hello world')
    result('hello ' + 'world')
  #+end_src

- What's what:
  1) ~result~ is a function name
  2) ~result~ is a parameter of the function ~result~
  3) ~result~ is an argument of the function call ~print~

- Can you call ~result~ inside ~result~? ([[https://pythontutor.com/visualize.html#code=def%20result%28result%29%3A%0A%20%20%20%20print%28result%29%0A%20%20%20%20result%281%29%0Aresult%282%29&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false][pythontutor.com]])
  #+begin_src python
    def result(result):
        print(result)
        result(1)
        result(2)
  #+end_src
  #+begin_quote
  - The ~TypeError: 'int' object is not callable~ is because at that
    point, ~result~ has been redefined as a parameter of the function,
    not the function itself.
  - When you try to call ~result(1)~ inside the function, you treat ~2~
    (the value passed as an argument to the function parameter) as a
    function - but ~2~ is an ~int~ and therefore not callable.
  #+end_quote

- A clearer version of this procedure:
  #+begin_src python
    def result(parameter):
        print(parameter)
        parameter(1) # Here parameter is not a function, it's the value
        # you passed (2)
    result(2)
  #+end_src

- How can you make a /recursive/ function that calls itself? ([[https://pythontutor.com/visualize.html#code=def%20result%28parameter%29%3A%0A%20%20%20%20print%28'Parameter%3A%20',%20parameter%29%0A%20%20%20%20if%20parameter%20%3E%200%3A%20%20%0A%20%20%20%20%20%20%20%20result%28parameter%20-%201%29%20%0Aresult%282%29&cumulative=false&curInstr=16&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false][PythonTutor]])
  #+begin_src python
    def result(parameter):
        print(f'Parameter: {parameter}')
        if parameter > 0:  # a base case to stop recursion
            result(parameter - 1)  # call function itself, not the parameter
            result(2)
  #+end_src

  #+RESULTS:
  : Parameter: 2
  : Parameter: 1
  : Parameter: 0

* TODO Practice defining functions without parameters:

1) In Colab, write a function ~count~ that takes a string ~str~ as an
   argument and prints the number of its characters.

2) Call ~count~ on these arguments: ~a~, ~abcd~, ~a b c d~. Output:

3) Is it Okay to call this function ~count~?
   #+begin_quote
   - It's OK to call your own function by a name used by Python: it
     will not affect the built-in function of the same name.
   - However, in your current scope (i.e. your Python session), it
     will overshadow the built-in function.
   - It is considered poor practice to re-use function names. In a
     modern editor, the syntax highlighting will tip you off.
   #+end_quote

4) Is it Okay to call the function parameter ~str~?
   #+begin_quote
   - It is OK to call a parameter inside your own function by a known
     name - it won't affect its use outside of the function.
   - However, inside the function, your name will overshadow the
     previous name used by Python.
   - It is considered poor practice to re-use keywords as names. In a
     modern editor, the syntax highlighting will tip you off.
   #+end_quote

5) Solution ([[https://pythontutor.com/visualize.html#code=%23%20function%20def%0Adef%20count%20%28str%29%3A%0A%20%20%20%20%20print%28str%29%0A%20%20%20%20%20print%28str.count%28''%29-1%29%0A%23%20function%20call%0Acount%28str%3D'abcd'%29%0Acount%28''%29%0Aprint%28str%28'0'%29%29%0A&cumulative=false&curInstr=12&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false][pythontutor with poor naming practice]]):
   #+begin_src python
     # function def
     def cnt (string):
         print(string.count('')-1)
         # function call
     cnt('a')
     cnt('abcd')
     cnt('a b c d')
     cnt(string='a b c d') # keyword parameter call
     print('abcd'.count('')-1)  # standard Python `str.count` function
   #+end_src

   #+RESULTS:
   : 1
   : 4
   : 7
   : 7
   : 4

* Return Values and ~return~ Statements

- Functions can also provide an /output/ or /return value/ using the
  ~return~ statement. It consists of:
  1) the ~return~ keyword
  2) the value or expression that the function should return.

- The ~return~ statement causes the function to exit.

- Example 1 (can you identify the terms?):
  #+begin_src python
    def getAnswer(answerNumber):
        if answerNumber == 42:
            return 'The meaning of life, the universe, and everything.'
  #+end_src

- Analysis of the function:
  1) ~getAnswer~ is a function
  2) It takes a parameter ~answerNumber~
  3) The function checks if parameter is equal to ~42~
  4) If the parameter is equal to ~42~, it returns a string.
  5) If the parameter is not equal to ~42~, it returns ~None~.

- Let's [[https://pythontutor.com/visualize.html#code=def%20getAnswer%28answerNumber%29%3A%0A%20%20%20%20if%20answerNumber%20%3D%3D%2042%3A%0A%20%20%20%20%20%20%20%20return%20'The%20meaning%20of%20life,%20the%20universe,%20and%20everything.'%0AgetAnswer%2842%29%0AgetAnswer%2840%29&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false][check this out in pythontutor]].

* Extended example: Magic 8 Ball

- Enter this code in Colab, then run it a few times ([[https://pythontutor.com/visualize.html#code=import%20random%0A%0Adef%20getAnswer%28answerNumber%29%3A%0A%20%20%20%20if%20answerNumber%20%3D%3D%201%3A%0A%20%20%20%20%20%20%20%20return%20'It%20is%20certain'%0A%20%20%20%20elif%20answerNumber%20%3D%3D%202%3A%0A%20%20%20%20%20%20%20%20return%20'It%20is%20decidedly%20so'%0A%20%20%20%20elif%20answerNumber%20%3D%3D%203%3A%0A%20%20%20%20%20%20%20%20return%20'Yes'%0A%20%20%20%20elif%20answerNumber%20%3D%3D%204%3A%0A%20%20%20%20%20%20%20%20return%20'Reply%20hazy%20try%20again'%0A%20%20%20%20elif%20answerNumber%20%3D%3D%205%3A%0A%20%20%20%20%20%20%20%20return%20'Ask%20again%20later'%0A%20%20%20%20elif%20answerNumber%20%3D%3D%206%3A%0A%20%20%20%20%20%20%20%20return%20'Concentrate%20and%20ask%20again'%0A%20%20%20%20elif%20answerNumber%20%3D%3D%207%3A%0A%20%20%20%20%20%20%20%20return%20'My%20reply%20is%20no'%0A%20%20%20%20elif%20answerNumber%20%3D%3D%208%3A%0A%20%20%20%20%20%20%20%20return%20'Outlook%20not%20so%20good'%0A%20%20%20%20elif%20answerNumber%20%3D%3D%209%3A%0A%20%20%20%20%20%20%20%20return%20'Very%20doubtful'%0A%0Ar%20%3D%20random.randint%281,%209%29%0Afortune%20%3D%20getAnswer%28r%29%0Aprint%28fortune%29%0AgetAnswer%2810%29&cumulative=false&curInstr=27&heapPrimitives=false&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false][pythontutor]]):
  #+begin_src python
    import random                  #1

    def getAnswer(answerNumber):   #2
        if answerNumber == 1:      #3
            return 'It is certain'
        elif answerNumber == 2:
            return 'It is decidely so'
        elif answerNumber == 3:
            return 'It is Yes'
        elif answerNumber == 4:
            return 'Reply hazy try again'
        elif answerNumber == 5:
            return 'Ask again later'
        elif answerNumber == 6:
            return 'Concentrate and ask again'
        elif answerNumber == 7:
            return 'My reply is no'
        elif answerNumber == 8:
            return 'Outlook not so good'
        elif answerNumber == 9:
            return 'Very doubtful'

    r = random.randint(1,9)        #4
    fortune = getAnswer(r)         #5
    print(fortune)                 #6
  #+end_src

- Analysis:
  1) Import ~random~ module for random number functions.
  2) Store a random integer from [1,9] in ~r~.
  3) Call function ~getAnswer~ with argument ~r~.
  4) Store ~return~ value from function in ~fortune~.
  5) ~print~ the ~fortune~.
  6) When calling a value outside of [1,9], ~None~ is ~return~ value.

* TODO Practice using return values and statements

** Calculate area of a rectangle

- Write a function called ~calculate_area~ that takes two parameters,
  ~length~ and ~width~, and calculates the ~area~ of a rectangle. The
  formula to calculate the area of a rectangle is ~area = length *
  width~. The function should return the calculated area via ~print~.

- Test the function with the values (4,5) and (7,3) for
  (length,width), and the expected output 20 and 21, respectively.

** Identify an even number

- Write a function called ~is_even~ that takes a single parameter,
  ~number~, and checks if the number is even. If the number is even, the
  function should return ~True~; otherwise, it should return ~False~.

- Tip: to check if a number N is even, you can use the modulus
  operator ~%~ - the modulus of any even number with 2 is zero.

- Test the function with the values 4 and 7.

* The ~None~ Value

- In Python, ~None~ represents the absence of a value.

- ~None~ is the only value of the ~NoneType~ data type (show this)[fn:1].
  #+begin_src python
    print(type(None))
  #+end_src
  
- ~None~ is used e.g. as the ~return~ value for ~print()~:
  #+begin_src python
    spam = print('Hello') # prints 'Hello'
    print(None == spam)   # spam now contains None
  #+end_src

- Python adds ~return None~ to the end of any function definition with
  no ~return~ statement.

- This is similar to how a ~while~ or ~for~ loop implicitly ends with a
  ~continue~ statement.

- Also, using ~return~ without a return value, returns ~None~. Show this!
  #+begin_src python
    def none():
        return 
    print(none())
  #+end_src  

* TODO Practice the ~None~ value

** Maximum value in a list

- Write a function called ~find_max~ that takes a list of numbers as a
  parameter and returns the maximum value in the list. If the list is
  empty, the function should return ~None~.

- Tip: you can use the built-in function ~max~ to identify the maximum
  number in a Python list, or you can devise your own algorithm.

- Test the function by calling it with these sample arguments:
  #+begin_example python
    print(find_max([2, 4, 6, 8, 10]))  # Output: 10
    print(find_max([]))  # Output: None
  #+end_example

** Check divisibility of two integers

- Write a function called ~check_divisibility~ that takes two integers,
  ~num~ and ~divisor~, as parameters. The function should check if ~num~ is
  divisible by ~divisor~ without a remainder. If it is divisible, the
  function should return ~True~; otherwise, it should return ~None~.

- Tip: to check if a number N is divisible by a number M, you can use
  the modulus operator ~%~ - the modulus of N and M is zero if they are
  divisible.
   
- Test the function with different arguments:
  #+begin_example python
    print(check_divisibility(10, 5))  # Output: True
    print(check_divisibility(10, 7))  # Output: None
  #+end_example


* NEXT Keyword Arguments and ~print()~

Keyword arguments allow you to specify optional parameters when
calling a function. One common function where keyword arguments are
used is the ~print()~ function. Let's see an example:

#+begin_src python
  print('Hello', end='')
  print('World')
#+end_src

The ~print()~ function has an optional parameter called ~end~, which
determines the string to append at the end of the printed output. By
default, ~end~ is set to ~'\n'~ (newline character). In the example above,
we override the default value of ~end~ by passing an empty string,
resulting in the output ~HelloWorld~ without any space or newline
between the words.

* TODO Practice keyword arguments and ~print~

Exercise 1:

- Write a function called create_sentence that takes three parameters:
  subject, verb, and object. The function should print a sentence
  using these parameters, with a space between each word. Use keyword
  arguments to make the order of the parameters flexible.

Exercise 2:

- Write a function called print_person_info that takes four
  parameters: name, age, city, and country. The function should print
  a formatted message that includes the person's information. Use
  keyword arguments to specify default values for city and country.

Here's an example solution to both exercises:
#+begin_src python
  # Exercise 1
  def create_sentence(subject, verb, object):
      print(subject, verb, object)

  # Exercise 2
  def print_person_info(name, age, city="Unknown", country="Unknown"):
      print(f"Name: {name}, Age: {age}, City: {city}, Country: {country}")
#+end_src

You can test these functions by calling them with different arguments:
#+begin_src python
  # Testing Exercise 1
  create_sentence(subject="I", verb="love", object="Python")  # Output: I love Python
  create_sentence(object="programming", subject="I", verb="enjoy")  # Output: I enjoy programming

  # Testing Exercise 2
  print_person_info("Alice", 25, city="New York", country="USA")
  # Output: Name: Alice, Age: 25, City: New York, Country: USA

  print_person_info("Bob", 30)
  # Output: Name: Bob, Age: 30, City: Unknown, Country: Unknown
#+end_src

* Local and Global Scope

Python functions have their own local scope, which means variables
defined within the function are only accessible within that
function. Parameters and variables assigned within a function are said
to exist in the local scope. Conversely, variables defined outside all
functions have a global scope and can be accessed from any part of the
program. It's important to understand the concept of scope to avoid
naming conflicts and understand variable visibility within your code.

- Example 3: can you define a function within another function?
  #+begin_src python
    # function definition
    def helloWorld():
        print('Hello, world!')
        def hello():
            return print('hello again')
        hello()
        # function call
    helloWorld()
  #+end_src

  #+RESULTS:
  : Hello, world!
  : hello again

* Practice local and global scope

Exercise 1:

- Write a function called calculate_sum that takes two parameters, a
  and b. Inside the function, declare a local variable called result
  and assign it the sum of a and b. Print the value of result inside
  the function. Then, outside the function, print the value of
  result. What do you observe? Explain the concept of local scope.

Exercise 2:

- Write a function called modify_global_variable that takes no
  parameters. Inside the function, declare a global variable called
  count and assign it an initial value of 0. Increment the value of
  count by 1. Print the value of count inside the function. Then,
  outside the function, print the value of count. What do you observe?
  Explain the concept of global scope.

Here's an example solution to both exercises:
#+begin_src python
  # Exercise 1
  def calculate_sum(a, b):
      result = a + b
      print("Inside the function:", result)

  calculate_sum(2, 3)  # Output: Inside the function: 5
  # print("Outside the function:", result)
  # Uncommenting this line will result in an error

  # In this exercise, when we try to access the variable `result` outside the function,
  # it results in a NameError. This is because `result` is defined in the local scope of the function
  # and is not accessible outside of it.

  # Exercise 2
  def modify_global_variable():
      global count
      count = 0
      count += 1
      print("Inside the function:", count)

  modify_global_variable()  # Output: Inside the function: 1
  print("Outside the function:", count)  # Output: Outside the function: 1

  # In this exercise, we declare `count` as a global variable inside the function
  # using the `global` keyword. This allows us to modify the global variable within the function,
  # and the changes made to `count` are reflected outside the function as well.
#+end_src

- In exercise 1, you'll notice that trying to access the local
  variable result outside the function results in a NameError. This
  demonstrates that variables defined within a function are said to
  exist in the local scope and are only accessible within that
  function.

- In exercise 2, by declaring count as a global variable inside the
  function, we are able to modify the global variable within the
  function and the changes persist outside the function. This
  illustrates the concept of global scope, where variables defined
  outside all functions can be accessed from any part of the program.

* The global statement

In Python, variables declared outside a function are considered global
by default. However, if you want to modify a global variable within a
function, you need to explicitly declare it using the ~global~
statement.

The ~global~ statement is used to indicate that a variable is a global
variable, even if it is assigned a value within a function. This
allows you to modify the global variable's value from within the
function's local scope.

Here's an example:

#+begin_src python
  count = 0

  def increment():
      global count
      count += 1

  increment()
  print(count)  ; Output: 1
#+end_src

In this example, we have a global variable ~count~ initialized with a
value of 0. The ~increment~ function uses the ~global~ statement to
indicate that ~count~ is a global variable, not a local one. It
increments the value of ~count~ by 1. When we call the ~increment~
function and print the value of ~count~, it has been modified to 1.

Using the ~global~ statement allows you to access and modify global
variables within a function. However, it's generally recommended to
minimize the use of global variables and favor passing values as
function parameters and returning results instead. This helps in
maintaining code clarity and avoiding unintended side effects.

* Practice the ~global~ statement

Exercise 1:

- Write a function called increment_count that takes no
  parameters. Inside the function, declare a global variable called
  count and assign it an initial value of 0. Increment the value of
  count by 1. Print the value of count inside the function. Then, call
  the function multiple times to observe how the global statement
  affects the variable.

Exercise 2:

- Write a function called modify_global_list that takes an element as
  a parameter. Inside the function, declare a global list called
  my_list and initialize it with some elements. Append the given
  element to my_list and print the updated list. Then, call the
  function multiple times with different elements to observe how the
  global statement allows modifications to the global list.

Here's an example solution to both exercises:
#+begin_src python
  # Exercise 1
  def increment_count():
      global count
      count = 0
      count += 1
      print("Inside the function:", count)

  increment_count()  # Output: Inside the function: 1
  increment_count()  # Output: Inside the function: 1 (count is reset to 0 every time)

  # In this exercise, we use the `global` statement to declare `count` as a global variable
  # inside the function. This allows us to modify the global variable `count` within the function.
  # However, note that each time the function is called, `count` is reset to 0, since it is declared inside the function.

  # Exercise 2
  def modify_global_list(element):
      global my_list
      my_list.append(element)
      print("Updated list:", my_list)

  my_list = [1, 2, 3]
  modify_global_list(4)  # Output: Updated list: [1, 2, 3, 4]
  modify_global_list(5)  # Output: Updated list: [1, 2, 3, 4, 5]

  # In this exercise, we use the `global` statement to declare `my_list` as a global list
  # inside the function. This allows us to modify the global list `my_list` by appending elements to it.
  # Each time the function is called, the given element is appended to the global list and the updated list is printed.
#+end_src

* Conclusion

Functions are an essential concept in Python programming. They provide
a way to encapsulate reusable code blocks, accept inputs through
parameters, and return outputs using return statements. Understanding
how to define and use functions effectively will enhance your code
organization, reusability, and overall readability. With the knowledge
gained from this lecture, you can start harnessing the power of
functions in your Python projects.

* IN PROGRESS Glossary

| TERM/COMMAND         | MEANING                                         |
|----------------------+-------------------------------------------------|
| Function definition  | Create a function                               |
| Function call        | Executing function (with/out passing arguments) |
| Function argument    | Value passed to a function in a function call   |
| Function parameter   | Variables that have arguments assigned to them  |
| Keyword parameter    | Paramater optionally called with a name         |
| Positional parameter | Parameter called with position only             |
| Recursive function   | Function that calls itself                      |

* Footnotes

[fn:1]In R, missing values are indicated by the ~NA~ special value,
which is of data type ~logical~ (aka Boolean). The ~pandas~ library in
Python, missing values are represented as ~NaN~ (Not a Number). Both
languages have many methods to deal with missing values, which are
a frequent problem in real datasets.

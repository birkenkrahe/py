#+TITLE:PYTHON LISTS, TUPLES and METHODS
#+AUTHOR: Marcus Birkenkrahe
#+SUBTITLE: CSC 109 - Introduction to programming in Python - Summer 2023
#+STARTUP: overview hideblocks indent inlineimages entitiespretty
#+PROPERTY: header-args:python :results output :exports both
* Overview
#+attr_latex: :width 400px
#+caption: Llyfrgell Genedlaethol Cymru / Llanfachraeth in darkness (1957)
[[../img/lists.jpg]]

- The ~list~ data type
- The ~tuple~ data type
- Augmented assignment operators
- Methods as type-specific functions
- References and pointers
- Conway's Game of Life

* The ~list~ data type

- A ~list~ contains multiple values in an ordered sequence.

- A ~list~ is a /value/ and can be stored in an object, and it also
  contains values also called /items/.

- The list items can be of any data type including lists:
  #+begin_src python
    print([1,2,3])   # numeric list (numeric items)
    print(['cat','bat','rat','elephant'])    # string list (string items)
    print(['hello', True, None, 42, 3.1415]) # mixed type list
  #+end_src

- Lists can be stored like any other value:
  #+begin_src python
    spam = ['cat', 'bat', 'rat']
    print(len(spam))    # number of items in spam
    print(type(spam))   # class of spam
    print([] == list('')) # empty list
  #+end_src

- ~spam~ is four things:
  1) a ~list~ variable (storage)
  2) a ~list~ value (stored)
  3) an ordered sequence of string values (indexed)
  4) an object (instanced)
  #+attr_latex: :width 400px
  #+caption: A list with its index values
  [[../img/7_list.png]]

* Practice list creation, extraction and deletion

You should be able to do all of these exercises with what you learnt
in the DataCamp course "Introduction to Python" ([[https://gist.github.com/birkenkrahe/0e1b69ba3ce842324335062842f28729][notebook in GitHub]]):

1) Assign these items to ~spam~ and extract them using a ranged ~for~ loop
   on one line separated by a single space: ~cat bat rat elephant~
   #+begin_src python
     spam = ['cat', 'bat', 'rat', 'elephant']
     for i in range(4):
         print(spam[i], end=' ')
   #+end_src

   #+RESULTS:
   : cat bat rat elephant 

2) What if the list has ~N~ elements? Can you generalize the loop?
   #+begin_src python
     spam = ['cat', 'bat', 'rat', 'elephant']
     for i in range(len(spam)):
         print(spam[i], end=' ')
   #+end_src

   #+RESULTS:
   : cat bat rat elephant 

3) Use elements of ~spam~ to print the sentence ~'The bat ate the cat.'~
   formatted with an f-string:
   #+begin_src python
     spam = ['cat', 'bat', 'rat', 'elephant']
     print(f"'The {spam[1]} ate the {spam[0]}.'")
   #+end_src

4) Which error do you get when you use an index that exceeds the number
   of values in your list value? Create an example.
   #+begin_src python :results silent
     spam = ['cat', 'bat', 'rat', 'elephant']
     print(spam[5])
   #+end_src

5) Can index values be non-integer? Find out!
   #+begin_src python :results output
     spam = ['cat', 'bat', 'rat', 'elephant']
     print(spam[int(1.0)])
     print(spam[1.0])
   #+end_src

   #+RESULTS:
   : bat
   
6) How can you extract the last number in this list of lists?
   #+begin_src python
     spam = [['cat','bat'], [10,20,30,40,50]]
   #+end_src
   #+begin_src python
     spam = [['cat','bat'], [10,20,30,40,50]]
     print(spam[1][4],
           spam[1][-1],
           spam[-1][4],
           spam[-1][-1],
           end='')
   #+end_src

   #+RESULTS:
   : 50 50 50 50

7) Write ~'The elephant is afraid of the bat.'~ using /negative/ indices
   of ~spam = ['cat', 'bat', 'rat', 'elephant']~:
   #+begin_src python
     spam = ['cat', 'bat', 'rat', 'elephant']
     print(f"'The {spam[-1]} is afraid of the {spam[-4]}.'")
   #+end_src

   #+RESULTS:
   : 'The elephant is afraid of the cat.'

8) From ~spam = ['cat', 'bat', 'rat', 'elephant']~, extract
   ~['cat','bat','rat']~:
   #+begin_src python
     spam = ['cat', 'bat', 'rat', 'elephant']
     print(spam[0:3],    # slicing first three elements
           spam[-4:-1],  # slicing first three elements 'from the rear'
           sep='\n')
     del spam[-1]        # deleting the last element
     print(spam)
   #+end_src

   #+RESULTS:
   : ['cat', 'bat', 'rat']
   : ['cat', 'bat', 'rat']
   : ['cat', 'bat', 'rat']

9) Change ~spam = ['cat', 'bat', 'rat', 'elephant']~ to the list
   ~['cat','armadillo','rat', 'armadillo']~:
   #+begin_src python
     spam = ['cat', 'bat', 'rat', 'elephant']
     spam[-1] = 'armadillo'
     print(spam)
     spam[1] = 'armadillo'
     print(spam)
   #+end_src

   #+RESULTS:
   : ['cat', 'bat', 'rat', 'armadillo']
   : ['cat', 'armadillo', 'rat', 'armadillo']

10) Create ~spam = ['cat', 'bat', 'cat', 'bat']~ by list concatenation
    and replication:
    #+begin_src python
      spam = ['cat','bat'] * 2
      print(spam)
      del spam
      spam = ['cat','bat'] + ['cat','bat']
      print(spam)
    #+end_src

    #+RESULTS:
    : ['cat', 'bat', 'cat', 'bat']
    : ['cat', 'bat', 'cat', 'bat']

* Working with lists - ~allMyCats~

- Here is a ~list~-less version of a program to get the names of six
  cats from the user and printing them ([[https://autbor.com/allmycats1/][pythontutor]]):
  #+begin_src python
    catName1 = input('Enter the name of cat 1: ')
    catName2 = input('Enter the name of cat 2: ')
    catName3 = input('Enter the name of cat 3: ')
    catName4 = input('Enter the name of cat 4: ')
    catName5 = input('Enter the name of cat 5: ')
    catName6 = input('Enter the name of cat 6: ')
    print(f'The cat names are: {catName1}, {catName2},\
     {catName3}, {catName4}, {catName5}, {catName6}')
  #+end_src

- Instead, use a single variable that contains a ~list~ value
  ([[https://autbor.com/allmycats2/][pythontutor]]):
  #+begin_src python
    catNames = []
    while True:
        print('Enter name of cat (or nothing to stop):')
        name = input()
        if name == '':
            break
        catNames = catNames + [name]
    if not catNames:
        print('You should get a cat')
    else:
        print('The cat names are:')
        for name in catNames:
            print(f'{name}')
  #+end_src
  1) Initialize empty list ~catNames~
  2) Infinite loop: ask for cat's ~name~ until empty entry
  3) Check if ~catNames~ were entered
  4) If ~catNames~ were entered, print them looping over the ~list~

* Looping over lists

- Notice how the ~for~ loop ranges over the list elements without ~range~:
  #+begin_src python
    for i in ['a','b', None, 10,100]:
        print(i,end=' ')
  #+end_src

- Can you print this list using a ~for~ loop with ~range~?
  #+begin_src python
    List = ['a','b', None, 10,100]
    for i in range(len(List)):
        print(List[i],end=' ')
  #+end_src  

- Instead of using ~range~ to get the integer index of the list items,
  call ~enumerate~ instead:
  #+begin_src python
    List = ['a','b', None, 10,100]
    for index, item in enumerate(List):
        print(f'Index {index} in the list is: {item}')
  #+end_src

- There is no simple way to get the name of ~List~ once it's been
  created because the variable name is just a /reference/ to the data.

- All ~global~ objects are available in a /dictionary/ ~globals().items()~.
  #+begin_src python
    print(globals().items())
  #+end_src
  
* Scope and lists

- Challenge:
  1) copy the code cell into a new code cell in Colab
  2) wrap the input routine into a function ~getCatNames()~
  3) make ~catNames~ global
  4) call ~getCatNames~ before the final printout.
  #+begin_src python
    def getCatNames():
        global catNames  # make `catNames` global
        catNames = [ ]
        while True:
            print('Enter name of cat (or nothing to stop):')
            name = input()
            if name == '':
                return
            catNames = catNames + [name]
        return catNames

    getCatNames()   # function call

    if not catNames:
        print('You should get a cat')
    else:
        print('The cat names are:')
        for name in catNames:
            print(f'{name}')
  #+end_src

- How could you keep ~catNames~ in local scope (inside the function) and
  still access its values outside?
  #+begin_src python
    def getCatNames():
        catNames = [ ]
        while True:
            print('Enter name of cat (or nothing to stop):')
            name = input()
            if name == '':
                return
            catNames = catNames + [name]
        return catNames

    myCatNames = getCatNames()
    print(myCatNames)
  #+end_src

* ~in~ or ~out~?

- The following script lets the user type in a pet name and then
  checks to see if the name is listed:
  #+begin_src python
    myPets = ['Nanny', 'Rosie', 'Poppy', 'Jack']
    name = input('Enter a pet name: ')
    if name not in myPets:
        print(f"I don't have a pet named {name}.")
    else:
        print(f"{name} is my pet.")
  #+end_src

* Multiple assignments (~tuple~ unpacking)

- You can assign multiple variables with the values in one line.

- The one assignment per line way:
  #+begin_src python
    cat = ['fast', 'moody', 'black']
    speed = cat[0]
    disposition = cat[1]
    color = cat[2]
    print(f'The {color} cat is {speed} and {disposition}')
  #+end_src

  #+RESULTS:
  : The black cat is fast and moody
  
- Multiple assignments: number of variables and length of list must be
  exactly equal otherwise you get a ~ValueError~.
  #+begin_src python
    cat = ['fast', 'moody', 'black']
    speed, disposition, color = cat # stored as tuple and unpacked
    print(f'The {color} cat is {speed} and {disposition}')
  #+end_src

  #+RESULTS:
  : The black cat is fast and moody

- Handle the ~ValueError~ that is caused by adding a variable ~name~ to
  the assignment:
  #+begin_src python
    cat = ['fast', 'moody', 'black']
    speed, disposition, color, name = cat # name is not known
    print(f'The {color} cat is {speed} and {disposition}')
  #+end_src

- Solution:
  1) put the assignment into a ~try~ clause and add a ~except ValueError:~
     clause
  2) to test, run original version (exception), then add ~'Jack'~ to ~cat~
     in the first line
  #+begin_src python
    cat = ['fast', 'moody', 'black']
    try:
        speed, disposition, color, name = cat
    except ValueError:
        print('ValueError - check multiple assignment')
    else:
        print(f'The {color} cat named {name} is {speed} and {disposition}')
  #+end_src

* Lists as ~random~ arguments

- The ~random.choice~ function will return a randomly selected item from
  the list:
  #+begin_src python
    import random
    pets = ['dog', 'cat', 'squirrel','moose','mouse','pony','snake']
    print(random.choice(pets))
  #+end_src

- This is a shorter form of ~pets[random.randint(0,len(pets)-1]~:
  #+begin_src python
    import random
    pets = ['dog', 'cat', 'squirrel','moose','mouse','pony','snake']
    print(pets[random.randint(0,len(pets)-1)])
  #+end_src

- The ~random.shuffle~ function will reorder the items in a list: it
  modifies the list /in place/ rather than returning a new list.
  #+begin_src python
    import random
    people = ['Alice', 'Bob', 'Carol', 'David']
    random.shuffle(people)
    print(people)
  #+end_src

* Augmented assignment operators
#+attr_latex: :width 400px
#+caption: Augmented assignment operators
[[../img/7_augmented.png]]

- These operators work for numbers, strings and lists:
  #+begin_src python
    spam = 'Hello, '
    spam += 'world!'   # equivalent to spam = spam + 'world!'
    print(spam)

    bacon = ['Huzza']
    bacon *= 3         # equivalent to bacon = bacon * 3
    print(bacon)
  #+end_src

  #+RESULTS:
  : Hello, world!
  : ['Huzza', 'Huzza', 'Huzza']

* Methods for specific data types

- Each data type as its own set of methods, e.g. the ~list~ data type
  has methods for finding, adding, removing and manipulating values.

- Examples:
  1) to call the ~list~ method ~index~ on the item ~'hello'~ of a list ~spam~:
     #+begin_src python
       spam = ['hello','world']
       print(spam.index('hello'))  # returns an index
     #+end_src
  2) to call the ~str~ method ~count~ on the substring ~'_'~ of the string
     ~'hello_world'~ stored in ~ham~:
     #+begin_src python
       ham = 'hello_world'
       print(ham.count('_'))  # returns a count
     #+end_src

- This approach transfers to other packages such a ~numpy~ or ~pandas~ -
  the focus of the methods is on the library purpose like numeric data
  processing or statistical analysis.

- Where applicable, I will contrast standard Python with NumPy and/or
  pandas (Kudos OpenAI: ChatGPT has been invaluable for this task.)

* Finding a value in a ~list~ with ~index~

- If the value is not in the list, a ~ValueError~ is raised:
  #+begin_src python
    spam = ['hello', 'hi', 'howdy', 'hey']
    print(spam.index('howdy'))
    print(spam.index('howdy howdy howdy'))
  #+end_src
- When there are duplicates, the first instance is returned:
  #+begin_src python
    spam = ['hello', 'hi', 'howdy', 'hey', 'hi']
    print(spam.index('hi'))
  #+end_src

* Finding a value in a numpy ~array~ with ~where~

- In NumPy, you can use the ~where~ function - a lot more information is
  available, but you need more skill to sort through it:
  #+begin_src python
    import numpy as np
    spam = ['hello', 'hi', 'howdy', 'hey', 'hi']

    # turn list into numpy array
    spam_np = np.array(spam)

    # store value of index for item 
    idx = np.where(spam_np == 'howdy')  

    print(idx)    # index informaion (full)
    print(idx[0][0])  # index only
    print(spam_np[idx])   # array value
  #+end_src

* Finding a value in a pandas ~series~ with ~

- In pandas, you can use Boolean indexing:
  #+begin_src python
    import pandas as pd

    # Create a pandas Series
    spam_pd = pd.Series(['hello', 'hi', 'howdy', 'hey', 'hi'])

    # Find the index where the value is equal to 'howdy'
    index = spam_pd[spam_pd == 'howdy'].index[0]

    print(index)
  #+end_src

- If the value is not found in the Series, it will raise an
  ~IndexError~.

* Adding values for lists with ~append~ and ~insert~

- You can add new values to a list with ~append~ (at the end) and
  ~insert~.

- Append ~'moose'~ at the end of ~spam~:
  #+begin_src python
    spam = ['cat', 'dog', 'bat']
    print(spam)
    spam.append('moose')
    print(spam)
  #+end_src

- Insert ~'chicken'~ as item number ~1~ into ~spam~:
  #+begin_src python
    spam = ['cat', 'dog', 'bat']
    print(spam)
    spam.insert(1,'chicken')
    print(spam)
  #+end_src

  #+RESULTS:
  : ['cat', 'dog', 'bat']
  : ['cat', 'chicken', 'dog', 'bat']
  
- These functions modify a list /in place/: neither of them gives the
  new value as a return value - they return ~None~ instead:
  #+begin_src python
    spam = ['cat', 'dog', 'bat']
    print(spam.append('moose'))
    print(spam)
    print(spam.insert(1,'chicken'))
    print(spam)
  #+end_src

- If that's so, what does ~spam = spam.append('elephant')~ do?
  #+begin_src python
    spam = ['cat', 'dog', 'bat']
    print(spam)
    spam = spam.append('elephant')
    print(spam)
  #+end_src

* Adding and inserting for NumPy ~array~

- By contrast, NumPy's ~np.append~ and ~np.insert~ methods create a new
  array and you need to assign the result back to the array to keep
  it:
  #+begin_src python
    import numpy as np

    spam_np = np.array(['cat', 'dog', 'bat', 'elephant'])

    print(spam_np)

    spam_np = np.append(spam_np, 'moose')

    print(spam_np)

    spam_np = np.insert(spam_np, 1, 'chicken')

    print(spam_np)
  #+end_src

- The behavior of NumPy for strings is tricky though: e.g. string
  items in the array will be truncated if the inserted string is
  larger than the largest string already in the array.

- To test that, run the code above and remove ~'elephant'~: the
  resulting inserted array will list ~'chick'~ and not ~'chicken'~.

- Numbers work better: an example with ~np.append~
  #+begin_src python
    import numpy as np

    # Create a numpy array
    arr = np.array([1, 2, 3, 4, 5])

    # Append a single value
    arr = np.append(arr, 6)
    print(arr)  # Output: [1 2 3 4 5 6]

    # Append multiple values
    arr = np.append(arr, [7, 8, 9])
    print(arr)  # Output: [1 2 3 4 5 6 7 8 9]
  #+end_src

- An example with ~np.insert~:
  #+begin_src python
    import numpy as np

    # Create a numpy array
    arr = np.array([1, 2, 3, 4, 5])

    # Insert a single value at index 2
    arr = np.insert(arr, 2, 6)
    print(arr)  # Output: [1 2 6 3 4 5]

    # Insert multiple values at index 3
    arr = np.insert(arr, 3, [7, 8, 9])
    print(arr)  # Output: [1 2 6 7 8 9 3 4 5]
  #+end_src  

  #+RESULTS:
  : [1 2 6 3 4 5]
  : [1 2 6 7 8 9 3 4 5]

* Trying to call a method on another data type

- The ~append~ and ~insert~ methods are ~list~ methods and won't work for
  strings or integers:
  #+begin_src python
    eggs = 'hello'
    eggs.append('world')
  #+end_src

- Calling ~insert~ on an integer:
  #+begin_src python
    bacon = 42
    bacon.insert(1,'world')
  #+end_src  

* Removing values from lists with ~remove~ or ~del~

- The ~remove~ method removes its arguments in place:
  #+begin_src python
    spam = ['cat','bat','rat','elephant']
    print(spam)
    spam.remove('bat')
    print(spam)
  #+end_src

- Trying to remove a value that does not exist raises a ~ValueError~:
  #+begin_src python
    spam = ['cat','bat','rat','elephant']
    spam.remove('chicken')
  #+end_src

- If there are multiple identical items, only the first will be
  removed:
  #+begin_src python
    spam = ['cat','bat','rat','elephant','cat','bat']
    print(spam)
    spam.remove('bat')
    print(spam)   # only the first instance is removed
  #+end_src

- Wondering at this point how many values you can remove at a time?
  Check the help (don't forget that this is a ~list~ method):
  #+begin_src python
    help(list.remove)
  #+end_src

  #+RESULTS:
  : Help on method_descriptor:
  : 
  : remove(self, value, /)
  :     Remove first occurrence of value.
  :     
  :     Raises ValueError if the value is not present.
  : 

- If you know the index of the item you want to remove, you can use
  the ~del~ keyword to delete items:
  #+begin_src python
    spam = ['cat','bat','rat','elephant','cat','bat']
    del spam[1]
    print(spam)
  #+end_src

- To remove more than one item at a time, you can either use a ~list~
  comprehension, or the ~filter~ function:
  #+begin_src python
    spam = ['cat','bat','rat','elephant','cat','bat']

    # Remove all 'bat' items
    spam = [item for item in spam if item != 'bat']

    print(spam)  # Output: ['cat', 'rat', 'elephant', 'cat']
  #+end_src

- The ~filter~ function takes an anonymous or ~lambda~ function as the
  argument:
  #+begin_src python
    spam = ['cat','bat','rat','elephant','cat','bat']

    # Remove all 'bat' items
    spam = list(filter(lambda item: item != 'bat', spam))

    print(spam)  # Output: ['cat', 'rat', 'elephant', 'cat']
  #+end_src

  #+RESULTS:
  : ['cat', 'rat', 'elephant', 'cat']

* TODO Sorting values in a list with ~sort~

* TODO Reversing values in a list with ~reverse~

* TODO Practice ~list~ methods

* TODO Example program: Magic 8 ball with a list
* TODO Sequence data types
* TODO References
* TODO Short program: Conway's Game of Life
* TODO Summary
* TODO Glossary
